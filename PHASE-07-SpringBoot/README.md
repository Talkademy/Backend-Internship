<div dir="rtl" align="justify">

فاز هفت: Spring Boot
=====

در فاز هفتم با [Spring Boot](https://en.wikipedia.org/wiki/Spring_Framework) که یک چارچوب (Framework) تحت جاوا است آشنا می‌شود.
1. مقدمه
   
   ابتدا بهتر است با مفهوم مایکروسرویس آشنا شویم. در حوزه‌ی نرم‌افزار دو نوع برنامه یا خدمت (Serivce) وجود دارد یکی سرویس‌های کوچک (Microservices) و دیگری سرویس‌های یک‌پارچه (Monolithic). برای مثال یک بازی کامپیوتری را در نظر بگیرید. برای آنکه بتوانید با آن کار کنید بعضا لازم است چند برنامه در کنار هم اجرا شوند تا برنامه به طور کامل قابل استفاده باشد. به عبارتی چندین واحد مجزا از هم وجود دارد که به صورت **یکپارچه** اجرا می‌شوند. در سوی دیگر سرویس‌های کوچک هستند که تنها و تنها یک فایل اجرایی دارند و حتی‌الامکان وابستگی‌های خود به برنامه‌های دیگر را کم می‌کنند و اکثر متغیرهای محیطی (Evnironmental variables) خود را از طریق چند پرونده‌ی جنب پیکربندی (Config) می‌کنند.
   اکنون می‌توانیم بگوییم که Spring Boot یک چارچوب است که به ما در ساخت یک وب‌سرویس کمک بسیاری می‌کند که می‌توان به تسهیل کار با پایگاه‌های داده، دریافت و ارسال پیام در معماری REST و کاهش زمان دیپلوی (deploy) اشاره کرد. در بخش‌های دو و سه با اجزای آن بهتر آشنا خواهیم شد.
2. Prooperties
   
   همانطور که دیدید، یکی از مزایای مایکروسرویس‌ها پیکربندی بدون تغییر برنامه است. به این صورت که یک پرونده‌ی `pref.config` یا `pref.properties` تعریف می‌کنید و برخی متغیرها را از آن می‌خوانید. Spring Boot به صورت پیش‌فرض از فایل‌هایی تحت عنوان `application<-phase>.properties` پشتیبانی می‌کند. به این صورت که شما می‌توانید برنامه‌ی خود را با متغیرهای ثابتی به ازای هر فاز (برای مثال در مقطع production یا test یا demo) اجرا کنید.
3. Component
   
   اگر به‌خاطر داشته باشید، در فاز چهارم با برخی از الگوهای طراحی از جمله `Singleton` آشنا شدید. برخی اشیاء در Spring Boot می‌بایست به صورت `Singleton` طراحی شوند زیرا تنها و تنها به یک عدد از آن‌ها در کل برنامه نیاز است که آن‌ها را به صورت اجمالی می‌توانیم اینگونه لیست کنیم:
   - Controller / RestController : برای مدیریت درخواست‌های دریافتی به سمت وب‌سرویس استفاده می‌شود. شما یک نگاشت (Mapping) برای هر درخواست درنظر می‌گیرید و خود کنترلر هنگام دریافت درخواست با تابع مناسب آن‌ها را تطبیق می دهد.
   - Service : کلاسی است که منطق برنامه را پشتیبانی می‌کند. برای مثال درخواستی به کنترلر می‌آید و سپس کنترلر آن را به یک سرویس پاس می‌دهد و پس از مدیریت درخواست پاسخ به کنترلر بازمی‌گردد و کنترلر آن را به کاربر خروجی می‌دهد. 
   - Repository : یک واسط برای ارتباط با پایگاه داده است. به این صورت که شما با تنظیمات ثبت شده در `application.properties` عملا پارامترهای مورد نیاز اتصال به پایگاه داده را تعیین کردید و با کمک `Repository` روی آن کوئری می‌زنید. به عبارتی زحمت نوشتن با رشته یا `Criteria` از دوش شما برداشته می‌شود. این Component تنها و تنها با `Service` در ارتباط است. در صورتی که این توالی را به درستی درک نکرده‌اید نگران نباشید! در مورد لایه‌های تجرید در فازهای آینده بیشتر آشنا خواهید شد.
   همچنین `Repository`ها برای ذخیره‌ی `Entity`ها به کار می‌روند که در حقیقت اشیاء حقیقی برنامه هستند. مانند `دانشجو` یا `استاد` در سامانه‌ی دانشگاهی. برای درک بیشتر مفهوم نها (Entity) می‌توانید از[این لینک](https://www.baeldung.com/jpa-entities) کمک بگیرید.
   - Configuration : به صورت سنتی از کلاس `Properties` در جاوا می‌توان برای خواندن پرونده‌های پیکربندی - یعنی اساسا هر پرونده با محتوای کلید:مقدار - بهره برد. اما در Spring Boot شما می‌توانید یک کلاس `Configuration` داشته باشید و با نام آن‌ها مقادیرشان را در لوای فیلد‌های جاوایی ثبت کنید. به عبارتی این کلاس مشابه یک `public static class Constants` است که شما در برنامه‌یتان از ثوابت آن استفاده می‌کنید.
4. REST
   
   از آنجایی که Spring Boot جهت طراحی وب‌سرویس‌ها استفاده می‌شود می‌بایست برنامه‌ی خود را دست کم با کی معماری وفق دهیم. REST یکی از چندین معماری موجود است. می‌توانیم ویژگی‌های REST را به صورت زیر خلاصه کنیم:
   - stateless : هر درخواست شما، مستقل از درخواست‌های پیشین شما بررسی می‌شود.
   - Server/Client : شاید شما نام `Torrent` به گوشتان خورده باشد. این بستر، جهت انتقال و تبادل فایل استفاده می‌شود ولی در آن هیچ مرکزیتی وجود ندارد؛ یعنی شما دنبال یک پرونده هستید و تمام سیستم‌های متصل به این بستر در نهایت جستجو می‌شوند تا شما پرونده‌ی مدنظرتان را پیدا کنید. به این ساختار Peer-to-Peer گفته می‌شود. اما وقتی شما در یک سایت دانلود دنبال برنامه‌ی به‌خصوصی هستید، آن سایت سرور و شما کلاینت خواهید بود. و مرکزیتی سمت آن سایت وجود دارد. معماری REST به این صورت است که شما برنامه‌ی خود را روی یک یا چند سرور دیپلوی می‌کنید و باقی جهان به صورت کلاینت به سرور(ها) شما متصل می‌شوند.
   - Path : همانطور که هنگام گشت درون یک ساختار پوشه‌بندی شما با زیرپوشه‌ها (Subdirectory) سروکار دارید، در معماری REST هم می‌توانید چنین کاری کنید. برای مثال فرض کنید شما یک بایگانی تحت وب پیاده‌سازی کرده‌اید که درمورد کتاب‌ها و مقالات دانشگاهی اطلاعات فراوانی دارد. اولین مسیر شما تعیین می‌کند که درخواست به `api.my_archive.com/book` برود یا `api.my_archive.com/paper`. سپس مممکن است هر کدام از این‌ها به زیرمسیرهای دیگری بروند.
   - HTTP Verb : در معماری REST می‌توانید از دستورات `GET`, `POST`, `PUT` و `DELETE` درخواست‌های خود را ارسال کنید. که تعیین کننده‌ی آن هاستند که شما تمایل دارید چه عملیاتی از سمت سرور انجام شود.
   - Body : بدنه‌ی درخواست شما که اغلب به صورت `JSON` یا `XML` است.
   - Header & Query Parameter (Inline variable) : شما می‌توانید برخی پارامترهای جنبی را به صورت سرآیند یا متغیر پرسمانی ارسال کنید.
   
نهایتا شما می‌توانید از لینک‌های زیر جهت آموزش، تفهیم و مثال بهره ببرید
* [Spring tutorial](https://www.tutorialspoint.com/spring_boot/index.htm) - دوازده فصل اول
* [Spring components](https://medium.com/technology-hits/spring-boot-framework-and-its-components-2725cecf0e62)
* [What is REST](https://www.codecademy.com/articles/what-is-rest)
* [Spring sample project](https://spring.io/guides/gs/rest-service/)

در صورتی که تمایل دارید با قابلیت‌های بیشتر Spring Boot آشنا شوید پیشنهاد می‌شود باقی فصول لینک اول را مطالعه کنید (بعضا در کنار فازهای پیش رو).
همچنین کتاب [Spring in action](https://doc.lagout.org/programmation/Spring%20Boot%20in%20Action.pdf) می‌تواند به شما درک عمیق‌تر در این زمینه دهد.

اهداف
=====
* آشنایی مقدماتی با مفهوم Microservice
* آشنایی با مفهوم Injection
* درک مقدماتی از تجرید لایه‌ها
* فهم نسبی معماری REST و توانایی کار با آن
* توانایی در ساخت یک وب‌سرویس با کنترلر و پایگاه داده با چارچوب Spring Boot
 
وظایف شما
=========
1. پرسش‌های نظری

   مثال بایگانی را در نظر بگیرید. فرض کنید در فاز یک این پروژه، قرار است برای مقاله و کتاب دو درخواست تعریف کنیم. یک، جستجو با کمک نام؛ دو، دریافت (یا امانت).
   1. به نظر شما از نظر معنایی این سامانه چند کنترلر و چند سرویس نیاز دارد؟ نام‌گذاری شما چگونه است؟
   2. به نظر شما نگاشت درخواست‌ها بهتر است ابتدا بر اساس نوع نوشته باشد یا نوع درخواست؟
   3. اگر بدانید در فازهای بعدی احتمالا انواع دیگری از نوشته ممکن است در این سامانه قرار گیرد و یا درخواست‌های متنوع‌تری اعمال شوند، طراحی خود در سوال قبل را تغییر می‌دهید؟
   4. به نظر شما استفاده از `@Configuration` چه مزیتی نسبت به یک کلاس استاتیک ثوابت دارد؟
2. [پروژه‌ی عملی](07-SpringBoot-Project.md)
</div>